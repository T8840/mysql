(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{446:function(_,v,l){"use strict";l.r(v);var n=l(2),i=Object(n.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"性能指标"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#性能指标"}},[_._v("#")]),_._v(" 性能指标")]),_._v(" "),v("ul",[v("li",[_._v("QPS：每秒钟处理的查询量")]),_._v(" "),v("li",[_._v("TPS：")]),_._v(" "),v("li",[_._v("并发量\n"),v("ul",[v("li",[_._v("大量的并发风险：数据库连接数被沾满(max_connections默认为100）")])])]),_._v(" "),v("li",[_._v("CPU使用率\n"),v("ul",[v("li",[_._v("超高的CPU使用率风险：因CPU资源耗尽而出现宕机")])])]),_._v(" "),v("li",[_._v("磁盘IO\n"),v("ul",[v("li",[_._v("风险：磁盘IO性能突然下降；其他大量消耗磁盘性能的计划任务")]),_._v(" "),v("li",[_._v("解决风险措施：使用更快的磁盘设备；调整计划任务，做好磁盘维护")])])]),_._v(" "),v("li",[_._v("网卡流量\n"),v("ul",[v("li",[_._v("如何避免无法连接数据库的情况\n"),v("ul",[v("li",[_._v("减少从服务器(slave)的数量")]),_._v(" "),v("li",[_._v("进行分级缓存")]),_._v(" "),v("li",[_._v("避免使用select *进行查询")]),_._v(" "),v("li",[_._v("分离业务网络和服务器网络")])])])])]),_._v(" "),v("li",[_._v("大表\n"),v("ul",[v("li",[_._v("大表的相对概念：记录行数巨大，单表超过千万行；表数据文件巨大，表数据文件超过10G")]),_._v(" "),v("li",[_._v("大表对查询的影响\n"),v("ul",[v("li",[_._v("慢查询：很难在一定时间内过滤出所需要的数据")])])]),_._v(" "),v("li",[_._v("大表对DDL操作的影响：\n"),v("ul",[v("li",[_._v("1.建立索引需要很长的时间\n"),v("ul",[v("li",[_._v("风险：MySQL版本<5.5建立索引会锁表")]),_._v(" "),v("li",[_._v("MySQL版本≥5.5版本虽然不会锁表但会引起主从延迟")])])]),_._v(" "),v("li",[_._v("2.修改表结构需要长时间锁表\n"),v("ul",[v("li",[_._v("风险：会造成长时间的主从延迟；影响正常的数据操作")])])])])]),_._v(" "),v("li",[_._v("如何处理数据库中的大表\n"),v("ul",[v("li",[_._v("1.分库分表把一张大表分成多个小表\n"),v("ul",[v("li",[_._v("难点：分表主键的选择；分表后跨分区数据的查询和统计")])])]),_._v(" "),v("li",[_._v("2.大表的历史数据归档：减少对前后端业务的影响\n"),v("ul",[v("li",[_._v("难点：归档时间点的选择；如何进行归档的操作")])])])])])])]),_._v(" "),v("li",[_._v("大事务\n"),v("ul",[v("li",[_._v("大事务定义：运行时间比较长，操作的数据比较多的事务\n"),v("ul",[v("li",[_._v("风险：锁定太多的数据，造成大量的阻塞和锁超时；回滚时所需的时间比较长；执行时间长，容易造成主从延迟")])])]),_._v(" "),v("li",[_._v("如何处理大事务\n"),v("ul",[v("li",[_._v("避免一次处理太多的数据")]),_._v(" "),v("li",[_._v("移出不必要在事务中的SELECT操作")])])])])])]),_._v(" "),v("h2",{attrs:{id:"什么因素影响了mysql数据库性能"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么因素影响了mysql数据库性能"}},[_._v("#")]),_._v(" 什么因素影响了MYSQL数据库性能")]),_._v(" "),v("ul",[v("li",[_._v("1.服务器硬性\n"),v("ul",[v("li",[_._v("如何选择服务器与版本\n"),v("ul",[v("li",[_._v("特殊情况\n"),v("ul",[v("li",[_._v("64位的mysql版本使用32位的服务器版本")])])])])]),_._v(" "),v("li",[_._v("如何选择内存")]),_._v(" "),v("li",[_._v("如何选择磁盘\n"),v("ul",[v("li",[_._v("1.存储容量 2.传输速度 3.访问时间 4.主轴转速  5.物理尺寸")])])])])]),_._v(" "),v("li",[_._v("2.服务器系统")]),_._v(" "),v("li",[_._v("3.数据库存储引擎的选择\n"),v("ul",[v("li",[_._v("MyISAM：不支持事务，表级锁")]),_._v(" "),v("li",[_._v("InnoDB：事务级存储引擎，完美支持行级锁，事务ACID特性")])])]),_._v(" "),v("li",[_._v("4.数据库参数配置（影响巨大）")]),_._v(" "),v("li",[_._v("5.数据库结构设计和SQL语句的编写\n"),v("ul",[v("li",[_._v("数据库设计对性能的影响的不好举措\n"),v("ul",[v("li",[_._v("1.过分的反范式话为表建立太多的列")]),_._v(" "),v("li",[_._v("2.过分的范式化造成太多的表关联")]),_._v(" "),v("li",[_._v("3.在OLTP环境中使用不恰当的分区表")]),_._v(" "),v("li",[_._v("4.使用外键保证数据的完整性")])])])])]),_._v(" "),v("li",[_._v("总结：\n"),v("ul",[v("li",[_._v("性能优化顺序\n"),v("ul",[v("li",[_._v("1.数据库结构设计和SQL语句")]),_._v(" "),v("li",[_._v("2.数据库存储引擎的选择和参数配置")]),_._v(" "),v("li",[_._v("3.系统选择及优化")]),_._v(" "),v("li",[_._v("4.硬件升级")])])])])])]),_._v(" "),v("h2",{attrs:{id:"优化系统配置"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#优化系统配置"}},[_._v("#")]),_._v(" 优化系统配置")]),_._v(" "),v("p",[_._v("系统参数控制着资源的配置，调整系统参数的值，可以帮助我们提升资源的利用效率。")]),_._v(" "),v("ol",[v("li",[v("p",[_._v("调整系统参数InnoDB_flush_log_at_trx_commit"),v("br"),_._v("\n这个参数存储在MySQL的配置文件my.ini里面，默认的值是1，意思是每次提交事务的时候，都把数据写入日志，并把日志写入磁盘。这样做的好处是数据安全性最佳，不足之处在于每次提交事务，都要进行磁盘写入的操作。在大并发的场景下，过于频繁的磁盘读写会导致CPU资源浪费，系统效率变低。"),v("br"),_._v("\n这个参数的值还有2个可能的选项，分别是0和2。其中，0表示每隔1秒将数据写入日志，并将日志写入磁盘；2表示，每次提交事务的时候都将数据写入日志，但是日志每间隔1秒写入磁盘。"),v("br"),_._v("\n最后，我们把这个参数的值改成了2。这样一来，就不用每次提交事务的时候都启动磁盘读写了，在大并发的场景下，可以改善系统效率，降低CPU使用率。即便出现故障，损失的数据也比较小。0虽然效率更高一些，但是数据安全性方面不如2。")])]),_._v(" "),v("li",[v("p",[_._v("调整系统参数InnoDB_buffer_pool_size"),v("br"),_._v("\n这个参数的意思是，InnoDB存储引擎使用缓存来存储索引和数据。这个值越大，可以加载到缓存区的索引和数据量就越多，需要的磁盘读写就越少。"),v("br"),_._v("\n因为我们的MySQL服务器是数据库专属服务器，只用来运行MySQL数据库服务，没有其他应用了，而我们的计算机是64位机，内存也有128G。于是我们把这个参数的值调整为64G。这样一来，磁盘读写次数可以大幅降低，我们就可以充分利用内存，释放出一些CPU的资源。")])]),_._v(" "),v("li",[v("p",[_._v("调整系统参数InnoDB_buffer_pool_instances"),v("br"),_._v("\n这个参数的意思是，将InnoDB的缓存区分成几个部分，这样一来，就可以提高系统的并行处理能力，因为可以允许多个进程同时处理不同部分的缓存区。")])])]),_._v(" "),v("p",[_._v("把InnoDB_buffer_pool_instances的值修改为64，意思就是把InnoDB的缓存区分成64个分区，这样就可以同时有多个进程进行数据操作，CPU的效率就高多了。")]),_._v(" "),v("p",[_._v("把InnoDB_buffer_pool_instances的值修改为64，意思就是把InnoDB的缓存区分成64\n个分区，这样就可以同时有多个进程进行数据操作，CPU的效率就高多了。")]),_._v(" "),v("h3",{attrs:{id:"cpu资源不足的问题的解决方案"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#cpu资源不足的问题的解决方案"}},[_._v("#")]),_._v(" CPU资源不足的问题的解决方案")]),_._v(" "),v("p",[_._v("CPU资源是系统的核心资源，获取成本非常高。CPU的特点就是阻塞，只要CPU一开始计算，就意味着等待。遇到CPU资源不足的问题，可以从2个思路去解决：")]),_._v(" "),v("ol",[v("li",[_._v("疏通拥堵路段，消除瓶颈，让等待的时间更短；")]),_._v(" "),v("li",[_._v("开拓新的通道，增加并行处理能力。")])]),_._v(" "),v("h3",{attrs:{id:"系统监控来诊断问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#系统监控来诊断问题"}},[_._v("#")]),_._v(" 系统监控来诊断问题")]),_._v(" "),v("p",[_._v("MySQL提供了很好的工具：Performance Schema。\n这是一种专门用来监控服务器执行情况的存储引擎，它会把监控服务器执行情况的数据记录在系统自带的数据库performance_schema中。我们可以利用监控的数据，对服务器中执行查询的问题进行诊断。\n系统数据库performance_schema中的表setup_instruments和setup_consumers中的数\n据，是启用监控的关键。")]),_._v(" "),v("ul",[v("li",[_._v("setup_instruments保存的数据，表示哪些对象发生的事件可以被系统捕获（在MySQL中，把这些事件称作信息生产者）。")]),_._v(" "),v("li",[_._v("setup_consumers这个表保存的数据，则指定了是否保存监控事件发生的信息。在MySQL中，PerformanceSchema把监控到的事件信息存入performance_schema中的数据表中，这些数据表保存了事件的监控信息，扮演了事件监控信息消费者的角色，被称为消费者。")])]),_._v(" "),v("p",[_._v("为了利用保存下来的监控事件信息来诊断系统问题，几个保存监控信息数据的系统数据表：")]),_._v(" "),v("ol",[v("li",[_._v("performance_schema.events_statements_current"),v("br"),_._v("\n这个表中记录的是当前系统中的查询事件。表中的每一行对应一个进程，一个进程只有一行数据，显示的是每个进程中被监控到的查询事件。")]),_._v(" "),v("li",[_._v("performance_schema.events_statements_history"),v("br"),_._v("\n这个表中记录了系统中所有进程中最近发生的查询事件。这个表中包含的查询事件都是已经完成了的。另外，表中可以为每个进程保存的最大记录数由系统变量决定。")]),_._v(" "),v("li",[_._v("performance_schema.events_statements_history_long"),v("br"),_._v("\n这个表中记录了系统中所有进程中最近发生的查询事件，表中包含的查询事件都是已经完成了的。同时，这个表中可以保存的记录数由系统变量决定。")])])])}),[],!1,null,null,null);v.default=i.exports}}]);